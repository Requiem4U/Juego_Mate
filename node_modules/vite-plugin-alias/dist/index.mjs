import { resolve } from 'node:path';
import { normalizePath } from 'vite';
import chokidar from 'chokidar';
import fs, { mkdir } from 'node:fs/promises';
import consola from 'consola';
import { parse, stringify } from 'comment-json';
import fg from 'fast-glob';
import { existsSync } from 'node:fs';

function split(string, seperator) {
  return string.split(seperator);
}
function toArray(value) {
  if (Array.isArray(value))
    return value;
  else
    return [value];
}
function toRelative(path, dir) {
  let folders = split(normalizePath(path), "/");
  folders = folders.slice(
    folders.findIndex((f) => f === dir),
    folders.length
  );
  return normalizePath(`./${folders.join("/")}`);
}
function toCamelCase(string) {
  return string.trim().replace(/[-_\s]+(.)?/g, (_, c) => c ? c.toUpperCase() : "");
}
const logger = consola.create({ defaults: { message: "[vite-plugin-alias] -" } });
function abort(message) {
  throw logger.error(new Error(message));
}
async function readJSON(path) {
  try {
    const file = (await fs.readFile(path, "utf-8")).toString();
    logger.success(`Config: ${path} successfully read!`);
    return parse(file);
  } catch (error) {
    logger.error(`File: ${path} was not found!`);
  }
}
async function writeJSON(path, data, process) {
  const name = path.replace(/^.*[\\\/]/, "");
  const state = process === "add" || process === "default" ? "created" : "updated";
  try {
    await fs.writeFile(path, stringify(data, null, 4));
    logger.success(`File: ${name} successfully ${state}`);
  } catch (error) {
    logger.error(`File: ${name} could not be ${state}.`);
    abort(error);
  }
}

const config = {
  dir: "src",
  prefix: "~",
  deep: true,
  depth: 1,
  createGlobalAlias: true,
  createLog: false,
  logPath: "src/logs",
  adjustDuplicates: false,
  useAbsolute: false,
  useConfig: false,
  useIndexes: false,
  useTypescript: false,
  root: process.cwd()
};
const IDEConfig = {
  compilerOptions: {
    baseUrl: ".",
    paths: {}
  }
};

async function writeConfig(gen, process = "default") {
  const { root, dir, useTypescript, useConfig } = gen.options;
  if (!useConfig)
    return;
  const name = useTypescript ? "tsconfig" : "jsconfig";
  const file = normalizePath(`${root}/${name}.json`);
  try {
    let json = await readJSON(file);
    if (!json) {
      IDEConfig.compilerOptions.paths = { ...gen.paths };
      json = Object.assign({}, IDEConfig);
    }
    if (!json.compilerOptions) {
      json.compilerOptions = {
        paths: { ...gen.paths }
      };
    }
    let paths = json.compilerOptions.paths || {};
    if (process === "remove") {
      paths = Object.fromEntries(
        /* eslint-disable array-callback-return */
        Object.entries(paths).filter((p) => {
          if (Object.values(gen.paths).flat().includes(p[1][0]) && p[1][0].includes(dir))
            return p;
          else if (!p[1][0].includes(dir))
            return p;
        })
      );
    }
    json.compilerOptions.paths = { ...paths, ...gen.paths };
    await writeJSON(file, json, process);
  } catch (error) {
    abort(`Cannot write Config: ${file}.`);
  }
}

async function getDirectories(gen) {
  const { dir, root, deep, depth } = gen.options;
  const directories = await fg.sync(deep ? `${dir}/**/*` : `${dir}/*`, {
    ignore: ["node_modules"],
    onlyDirectories: true,
    cwd: root,
    deep: depth,
    absolute: true
  });
  if (!directories.length)
    logger.error(new Error("No Directories could be found!"));
  gen.addAlias(directories);
}

async function writeLog(gen, process = "default") {
  const { createLog, logPath } = gen.options;
  if (!createLog)
    return;
  const folder = normalizePath(logPath);
  const file = normalizePath(`${folder}/alias.json`);
  const data = gen.alias;
  try {
    if (!existsSync(folder))
      await mkdir(folder, { recursive: true });
    await writeJSON(file, data, process);
  } catch (error) {
    abort(`Cannot create Logfolder ${folder}.`);
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class Generator {
  constructor(servermode, options) {
    this.servermode = servermode;
    __publicField(this, "options");
    __publicField(this, "fullPath");
    __publicField(this, "alias", []);
    __publicField(this, "directories", /* @__PURE__ */ new Set());
    __publicField(this, "paths", {});
    /**
     * Glob directories
     * writes Logfile
     * writes IDE Config
     */
    __publicField(this, "searched", false);
    this.options = Object.assign({}, config, options);
    this.fullPath = normalizePath(resolve(this.options.root, this.options.dir));
    if (servermode === "serve")
      this.observe();
  }
  /**
   * Add Alias
   * @param path
   */
  addAlias(path) {
    toArray(path).forEach((p) => {
      const correctedPath = normalizePath(p);
      const folders = split(correctedPath.replace(this.fullPath, this.options.dir), "/").filter(Boolean);
      const lastDir = folders.slice(-1)[0];
      let key = `${this.options.prefix}${lastDir}`;
      const uniqueFolders = [...new Set(folders)];
      this.checkForDuplicates(correctedPath, folders, uniqueFolders);
      if (this.alias.some((a) => a.find === key)) {
        logger.warn(
          "There are duplicate alias generated, either fix the folderstructure or enable adjustDuplicates."
        );
        if (this.options.adjustDuplicates && this.options.depth > 1) {
          const name = folders.filter((f) => !split(normalizePath(this.options.dir), "/").includes(f)).join("-");
          key = `${this.options.prefix}${toCamelCase(name)}`;
        }
      }
      if (lastDir === this.options.dir && this.options.createGlobalAlias)
        key = `${this.options.prefix}`;
      this.directories.add(p);
      this.alias.push({
        find: `${key}`,
        replacement: `${p}`
      });
      const configPath = this.options.useAbsolute ? correctedPath : toRelative(correctedPath, this.options.dir);
      if (this.options.useIndexes)
        this.paths[key] = [configPath];
      else
        this.paths[`${key}/*`] = [`${configPath}/*`];
    });
  }
  /**
   * Remove Alias
   * @param path
   */
  removeAlias(path) {
    toArray(path).forEach((p) => {
      const correctedPath = normalizePath(p);
      if (this.directories.has(correctedPath)) {
        this.directories.delete(correctedPath);
        this.alias = this.alias.filter((a) => a.replacement !== correctedPath);
        this.paths = Object.fromEntries(
          Object.entries(this.paths).filter(
            (configPath) => configPath[1][0].slice(0, -2) !== (this.options.useIndexes ? correctedPath : `${correctedPath}/*`)
          )
        );
      }
    });
  }
  /**
     * Check for duplicates before adding them as alias
     * @param initialPath
     * @param folders
     * @param uniqueFolders
     */
  checkForDuplicates(initialPath, folders, uniqueFolders) {
    if (folders.length !== uniqueFolders.length) {
      const duplicateFolders = [...folders].sort().filter((f, i, self) => {
        if (self[i + 1] === self[i])
          return f;
      });
      logger.warn(`Path: '${initialPath}' contains multiple folders with same name: ${duplicateFolders.toString()}.`);
    }
  }
  async init() {
    if (this.searched)
      return;
    await getDirectories(this);
    if (this.options.createGlobalAlias)
      this.addAlias(this.fullPath);
    writeLog(this);
    writeConfig(this);
    this.searched = true;
  }
  /**
   * Watch for directory changes
   */
  observe() {
    const watcher = chokidar.watch(this.fullPath, { ignoreInitial: true, depth: this.options.depth });
    watcher.on("addDir", (path) => {
      this.addAlias(path);
      writeLog(this, "add");
      writeConfig(this, "add");
      logger.info(`Watcher added new Path: ${path}`);
    }).on("unlinkDir", (path) => {
      this.removeAlias(path);
      writeLog(this, "remove");
      writeConfig(this, "remove");
      logger.info(`Watcher removed Path: ${path}`);
    });
  }
}

function Alias(options = {}) {
  let gen;
  return {
    name: "vite-plugin-alias",
    enforce: "pre",
    config(config, { command }) {
      gen = new Generator(command, options);
      gen.init();
      config.resolve = {
        alias: config.resolve?.alias ? [...config.resolve.alias, ...gen.alias] : gen.alias
      };
    }
  };
}

export { Alias as default };
